diff --git a/src/gadgetlib1/gadgets/hashes/sha256/sha256_gadget.hpp b/src/gadgetlib1/gadgets/hashes/sha256/sha256_gadget.hpp
index 8cb6365..6efd954 100644
--- a/src/gadgetlib1/gadgets/hashes/sha256/sha256_gadget.hpp
+++ b/src/gadgetlib1/gadgets/hashes/sha256/sha256_gadget.hpp
@@ -41,6 +41,8 @@ public:
     pb_variable_array<FieldT> unreduced_output;
     pb_variable_array<FieldT> reduced_output;
     std::vector<lastbits_gadget<FieldT> > reduce_output;
+
+    std::shared_ptr<digest_variable<FieldT>> internal_output;
 public:
     pb_linear_combination_array<FieldT> prev_output;
     pb_variable_array<FieldT> new_block;
diff --git a/src/gadgetlib1/gadgets/hashes/sha256/sha256_gadget.tcc b/src/gadgetlib1/gadgets/hashes/sha256/sha256_gadget.tcc
index 82c9780..b1b3838 100644
--- a/src/gadgetlib1/gadgets/hashes/sha256/sha256_gadget.tcc
+++ b/src/gadgetlib1/gadgets/hashes/sha256/sha256_gadget.tcc
@@ -11,6 +11,8 @@
  * @copyright  MIT license (see LICENSE file)
  *****************************************************************************/
 
+#include "crypto/sha256.h"
+
 #ifndef SHA256_GADGET_TCC_
 #define SHA256_GADGET_TCC_
 
@@ -27,125 +29,193 @@ sha256_compression_function_gadget<FieldT>::sha256_compression_function_gadget(p
     new_block(new_block),
     output(output)
 {
-    /* message schedule and inputs for it */
-    packed_W.allocate(pb, 64, FMT(this->annotation_prefix, " packed_W"));
-    message_schedule.reset(new sha256_message_schedule_gadget<FieldT>(pb, new_block, packed_W, FMT(this->annotation_prefix, " message_schedule")));
-
-    /* initalize */
-    round_a.push_back(pb_linear_combination_array<FieldT>(prev_output.rbegin() + 7*32, prev_output.rbegin() + 8*32));
-    round_b.push_back(pb_linear_combination_array<FieldT>(prev_output.rbegin() + 6*32, prev_output.rbegin() + 7*32));
-    round_c.push_back(pb_linear_combination_array<FieldT>(prev_output.rbegin() + 5*32, prev_output.rbegin() + 6*32));
-    round_d.push_back(pb_linear_combination_array<FieldT>(prev_output.rbegin() + 4*32, prev_output.rbegin() + 5*32));
-    round_e.push_back(pb_linear_combination_array<FieldT>(prev_output.rbegin() + 3*32, prev_output.rbegin() + 4*32));
-    round_f.push_back(pb_linear_combination_array<FieldT>(prev_output.rbegin() + 2*32, prev_output.rbegin() + 3*32));
-    round_g.push_back(pb_linear_combination_array<FieldT>(prev_output.rbegin() + 1*32, prev_output.rbegin() + 2*32));
-    round_h.push_back(pb_linear_combination_array<FieldT>(prev_output.rbegin() + 0*32, prev_output.rbegin() + 1*32));
-
-    /* do the rounds */
-    for (size_t i = 0; i < 64; ++i)
-    {
-        round_h.push_back(round_g[i]);
-        round_g.push_back(round_f[i]);
-        round_f.push_back(round_e[i]);
-        round_d.push_back(round_c[i]);
-        round_c.push_back(round_b[i]);
-        round_b.push_back(round_a[i]);
-
-        pb_variable_array<FieldT> new_round_a_variables;
-        new_round_a_variables.allocate(pb, 32, FMT(this->annotation_prefix, " new_round_a_variables_%zu", i+1));
-        round_a.emplace_back(new_round_a_variables);
-
-        pb_variable_array<FieldT> new_round_e_variables;
-        new_round_e_variables.allocate(pb, 32, FMT(this->annotation_prefix, " new_round_e_variables_%zu", i+1));
-        round_e.emplace_back(new_round_e_variables);
-
-        round_functions.push_back(sha256_round_function_gadget<FieldT>(pb,
-                                                                       round_a[i], round_b[i], round_c[i], round_d[i],
-                                                                       round_e[i], round_f[i], round_g[i], round_h[i],
-                                                                       packed_W[i], SHA256_K[i], round_a[i+1], round_e[i+1],
-                                                                       FMT(this->annotation_prefix, " round_functions_%zu", i)));
-    }
-
-    /* finalize */
-    unreduced_output.allocate(pb, 8, FMT(this->annotation_prefix, " unreduced_output"));
-    reduced_output.allocate(pb, 8, FMT(this->annotation_prefix, " reduced_output"));
-    for (size_t i = 0; i < 8; ++i)
-    {
-        reduce_output.push_back(lastbits_gadget<FieldT>(pb,
-                                                        unreduced_output[i],
-                                                        32+1,
-                                                        reduced_output[i],
-                                                        pb_variable_array<FieldT>(output.bits.rbegin() + (7-i) * 32, output.bits.rbegin() + (8-i) * 32),
-                                                        FMT(this->annotation_prefix, " reduce_output_%zu", i)));
+    if (!pb.unsafe_speedup) {
+        /* message schedule and inputs for it */
+        packed_W.allocate(pb, 64, FMT(this->annotation_prefix, " packed_W"));
+        message_schedule.reset(new sha256_message_schedule_gadget<FieldT>(pb, new_block, packed_W, FMT(this->annotation_prefix, " message_schedule")));
+
+        /* initalize */
+        round_a.push_back(pb_linear_combination_array<FieldT>(prev_output.rbegin() + 7*32, prev_output.rbegin() + 8*32));
+        round_b.push_back(pb_linear_combination_array<FieldT>(prev_output.rbegin() + 6*32, prev_output.rbegin() + 7*32));
+        round_c.push_back(pb_linear_combination_array<FieldT>(prev_output.rbegin() + 5*32, prev_output.rbegin() + 6*32));
+        round_d.push_back(pb_linear_combination_array<FieldT>(prev_output.rbegin() + 4*32, prev_output.rbegin() + 5*32));
+        round_e.push_back(pb_linear_combination_array<FieldT>(prev_output.rbegin() + 3*32, prev_output.rbegin() + 4*32));
+        round_f.push_back(pb_linear_combination_array<FieldT>(prev_output.rbegin() + 2*32, prev_output.rbegin() + 3*32));
+        round_g.push_back(pb_linear_combination_array<FieldT>(prev_output.rbegin() + 1*32, prev_output.rbegin() + 2*32));
+        round_h.push_back(pb_linear_combination_array<FieldT>(prev_output.rbegin() + 0*32, prev_output.rbegin() + 1*32));
+
+        /* do the rounds */
+        for (size_t i = 0; i < 64; ++i)
+        {
+            round_h.push_back(round_g[i]);
+            round_g.push_back(round_f[i]);
+            round_f.push_back(round_e[i]);
+            round_d.push_back(round_c[i]);
+            round_c.push_back(round_b[i]);
+            round_b.push_back(round_a[i]);
+
+            pb_variable_array<FieldT> new_round_a_variables;
+            new_round_a_variables.allocate(pb, 32, FMT(this->annotation_prefix, " new_round_a_variables_%zu", i+1));
+            round_a.emplace_back(new_round_a_variables);
+
+            pb_variable_array<FieldT> new_round_e_variables;
+            new_round_e_variables.allocate(pb, 32, FMT(this->annotation_prefix, " new_round_e_variables_%zu", i+1));
+            round_e.emplace_back(new_round_e_variables);
+
+            round_functions.push_back(sha256_round_function_gadget<FieldT>(pb,
+                                                                           round_a[i], round_b[i], round_c[i], round_d[i],
+                                                                           round_e[i], round_f[i], round_g[i], round_h[i],
+                                                                           packed_W[i], SHA256_K[i], round_a[i+1], round_e[i+1],
+                                                                           FMT(this->annotation_prefix, " round_functions_%zu", i)));
+        }
+
+        /* finalize */
+        unreduced_output.allocate(pb, 8, FMT(this->annotation_prefix, " unreduced_output"));
+        reduced_output.allocate(pb, 8, FMT(this->annotation_prefix, " reduced_output"));
+        for (size_t i = 0; i < 8; ++i)
+        {
+            reduce_output.push_back(lastbits_gadget<FieldT>(pb,
+                                                            unreduced_output[i],
+                                                            32+1,
+                                                            reduced_output[i],
+                                                            pb_variable_array<FieldT>(output.bits.rbegin() + (7-i) * 32, output.bits.rbegin() + (8-i) * 32),
+                                                            FMT(this->annotation_prefix, " reduce_output_%zu", i)));
+        }
+    } else {
+        internal_output.reset(new digest_variable<FieldT>(pb, 256, "lol"));
     }
 }
 
 template<typename FieldT>
 void sha256_compression_function_gadget<FieldT>::generate_r1cs_constraints()
 {
-    message_schedule->generate_r1cs_constraints();
-    for (size_t i = 0; i < 64; ++i)
-    {
-        round_functions[i].generate_r1cs_constraints();
-    }
-
-    for (size_t i = 0; i < 4; ++i)
-    {
-        this->pb.add_r1cs_constraint(r1cs_constraint<FieldT>(1,
-                                                             round_functions[3-i].packed_d + round_functions[63-i].packed_new_a,
-                                                             unreduced_output[i]),
-            FMT(this->annotation_prefix, " unreduced_output_%zu", i));
-
-        this->pb.add_r1cs_constraint(r1cs_constraint<FieldT>(1,
-                                                             round_functions[3-i].packed_h + round_functions[63-i].packed_new_e,
-                                                             unreduced_output[4+i]),
-            FMT(this->annotation_prefix, " unreduced_output_%zu", 4+i));
-    }
-
-    for (size_t i = 0; i < 8; ++i)
-    {
-        reduce_output[i].generate_r1cs_constraints();
+    if (!this->pb.unsafe_speedup) {
+        message_schedule->generate_r1cs_constraints();
+        for (size_t i = 0; i < 64; ++i)
+        {
+            round_functions[i].generate_r1cs_constraints();
+        }
+
+        for (size_t i = 0; i < 4; ++i)
+        {
+            this->pb.add_r1cs_constraint(r1cs_constraint<FieldT>(1,
+                                                                 round_functions[3-i].packed_d + round_functions[63-i].packed_new_a,
+                                                                 unreduced_output[i]),
+                FMT(this->annotation_prefix, " unreduced_output_%zu", i));
+
+            this->pb.add_r1cs_constraint(r1cs_constraint<FieldT>(1,
+                                                                 round_functions[3-i].packed_h + round_functions[63-i].packed_new_e,
+                                                                 unreduced_output[4+i]),
+                FMT(this->annotation_prefix, " unreduced_output_%zu", 4+i));
+        }
+
+        for (size_t i = 0; i < 8; ++i)
+        {
+            reduce_output[i].generate_r1cs_constraints();
+        }
+    } else {
+        // The internal output needs to equal the final output
+        // digest. This prevents another witness from overwriting
+        // the digest -- since the constraints will fail.
+
+        for (size_t i = 0; i < 256; i++) {
+            this->pb.add_r1cs_constraint(r1cs_constraint<FieldT>(
+                1,
+                internal_output->bits[i],
+                output.bits[i]
+            ), "FAKE_SHA256");
+        }
     }
 }
 
 template<typename FieldT>
 void sha256_compression_function_gadget<FieldT>::generate_r1cs_witness()
 {
-    message_schedule->generate_r1cs_witness();
-
-#ifdef DEBUG
-    printf("Input:\n");
-    for (size_t j = 0; j < 16; ++j)
-    {
-        printf("%lx ", this->pb.val(packed_W[j]).as_ulong());
-    }
-    printf("\n");
-#endif
-
-    for (size_t i = 0; i < 64; ++i)
-    {
-        round_functions[i].generate_r1cs_witness();
-    }
-
-    for (size_t i = 0; i < 4; ++i)
-    {
-        this->pb.val(unreduced_output[i]) = this->pb.val(round_functions[3-i].packed_d) + this->pb.val(round_functions[63-i].packed_new_a);
-        this->pb.val(unreduced_output[4+i]) = this->pb.val(round_functions[3-i].packed_h) + this->pb.val(round_functions[63-i].packed_new_e);
-    }
-
-    for (size_t i = 0; i < 8; ++i)
-    {
-        reduce_output[i].generate_r1cs_witness();
-    }
-
-#ifdef DEBUG
-    printf("Output:\n");
-    for (size_t j = 0; j < 8; ++j)
-    {
-        printf("%lx ", this->pb.val(reduced_output[j]).as_ulong());
+    if (!this->pb.unsafe_speedup) {
+        message_schedule->generate_r1cs_witness();
+
+    #ifdef DEBUG
+        printf("Input:\n");
+        for (size_t j = 0; j < 16; ++j)
+        {
+            printf("%lx ", this->pb.val(packed_W[j]).as_ulong());
+        }
+        printf("\n");
+    #endif
+
+        for (size_t i = 0; i < 64; ++i)
+        {
+            round_functions[i].generate_r1cs_witness();
+        }
+
+        for (size_t i = 0; i < 4; ++i)
+        {
+            this->pb.val(unreduced_output[i]) = this->pb.val(round_functions[3-i].packed_d) + this->pb.val(round_functions[63-i].packed_new_a);
+            this->pb.val(unreduced_output[4+i]) = this->pb.val(round_functions[3-i].packed_h) + this->pb.val(round_functions[63-i].packed_new_e);
+        }
+
+        for (size_t i = 0; i < 8; ++i)
+        {
+            reduce_output[i].generate_r1cs_witness();
+        }
+
+    #ifdef DEBUG
+        printf("Output:\n");
+        for (size_t j = 0; j < 8; ++j)
+        {
+            printf("%lx ", this->pb.val(reduced_output[j]).as_ulong());
+        }
+        printf("\n");
+    #endif
+    } else {
+        // Just perform SHA256 on the input.
+
+        std::vector<bool> input_iv;
+        std::vector<bool> input_digest;
+
+        for (size_t i = 0; i < 512; i++) {
+            input_digest.push_back(this->pb.val(new_block[i]) == FieldT::one());
+        }
+
+        for (size_t i = 0; i < 256; i++) {
+            input_iv.push_back(this->pb.lc_val(prev_output[i]) == FieldT::one());
+        }
+
+        CSHA256 hasher;
+        for (size_t i = 0; i < 8; i++) {
+            hasher.s[i] = 0;
+            for (size_t j = 0; j < 32; j++) {
+                hasher.s[i] |= (input_iv[(i * 32) + j] ? 0x00000001 : 0) << (31 - j);
+            }
+        }
+
+        std::vector<unsigned char> digest_v;
+        for (size_t i = 0; i < 64; i++) {
+            unsigned char b = 0;
+            for (size_t j = 0; j < 8; j++) {
+                b |= (input_digest[(i * 8) + j] ? 0x01 : 0) << (7 - j);
+            }
+            digest_v.push_back(b);
+        }
+        assert(digest_v.size() == 64);
+        hasher.Write(&digest_v[0], 64);
+
+        std::vector<unsigned char> final_digest(32, 0x00);
+        hasher.FinalizeNoPadding(&final_digest[0]);
+        assert(final_digest.size() == 32);
+
+        for (size_t i = 0; i < 32; i++) {
+            for (size_t j = 0; j < 8; j++) {
+                if (final_digest[i] & (0x01 << (7 - j))) {
+                    this->pb.val(internal_output->bits[(i * 8) + j]) = FieldT::one();
+                    this->pb.val(output.bits[(i * 8) + j]) = FieldT::one();
+                } else {
+                    this->pb.val(internal_output->bits[(i * 8) + j]) = FieldT::zero();
+                    this->pb.val(output.bits[(i * 8) + j]) = FieldT::zero();
+                }
+            }
+        }
     }
-    printf("\n");
-#endif
 }
 
 template<typename FieldT>
diff --git a/src/gadgetlib1/protoboard.hpp b/src/gadgetlib1/protoboard.hpp
index a9c30b4..4548e70 100644
--- a/src/gadgetlib1/protoboard.hpp
+++ b/src/gadgetlib1/protoboard.hpp
@@ -37,6 +37,7 @@ private:
 
 public:
     protoboard();
+    bool unsafe_speedup;
 
     void clear_values();
 
diff --git a/src/gadgetlib1/protoboard.tcc b/src/gadgetlib1/protoboard.tcc
index 61f50ad..b32b1da 100644
--- a/src/gadgetlib1/protoboard.tcc
+++ b/src/gadgetlib1/protoboard.tcc
@@ -15,7 +15,7 @@
 namespace libsnark {
 
 template<typename FieldT>
-protoboard<FieldT>::protoboard()
+protoboard<FieldT>::protoboard() : unsafe_speedup(false)
 {
     constant_term = FieldT::one();
 
